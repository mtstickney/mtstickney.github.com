<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>FiddlyBits</title><link href="http://mtstickney.github.io/" rel="alternate"></link><link href="http://mtstickney.github.io/feeds/blog.atom.xml" rel="self"></link><id>http://mtstickney.github.io/</id><updated>2015-10-27T00:00:00-04:00</updated><entry><title>Polymorphic Functions in ABL</title><link href="http://mtstickney.github.io/posts/2015/10/27/polymorphic-functions-in-abl.html" rel="alternate"></link><updated>2015-10-27T00:00:00-04:00</updated><author><name>Matthew Stickney</name></author><id>tag:mtstickney.github.io,2015-10-27:posts/2015/10/27/polymorphic-functions-in-abl.html</id><summary type="html">&lt;p&gt;Tags: abl, OO, experiments&lt;/p&gt;
&lt;p&gt;If you've ever looked at books on refactoring code, there's one common
theme among them: every piece of refactoring advice that has ever been
given assumes the existence of an object system in your language&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;At work, we use this crummy business-oriented language called ABL. It
actually has objects, despite their
&lt;a href="https://blog.abevoelker.com/progress_openedge_abl_considered_harmful/"&gt;many shortcomings&lt;/a&gt;&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;,
but they come at a prohibitive cost for us: they require manual
memory management, and there are a number of subtle compiler bugs that
affects code compiled one one version and run on another.&lt;/p&gt;
&lt;p&gt;So what's a down-and-out developer to do? If you squint hard enough,
you'll notice that objects are useful for refactoring mostly because
they provide polymorphic methods. Encapsulation is largely handled by
forward-declaring functions (and ABL doesn't even have the notion of a
struct, so no need to worry about those), and while inheritance is
nice, it's mostly a convenience. Polymorphism allows you to substitute
implementations without changing the code that uses them, which allows
hard code dependencies to be broken.&lt;/p&gt;
&lt;h1&gt;Requirements&lt;/h1&gt;
&lt;p&gt;I wanted to see if I could provide polymorphism in ABL without the
drawbacks of objects. There were a few requirements:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Implementations must be able to be stored in variables and passed
   to functions.&lt;/li&gt;
&lt;li&gt;Implementations shouldn't require explicit create/release calls.&lt;/li&gt;
&lt;li&gt;The system should allow basic mistakes like typos to be caught at
compile time.&lt;/li&gt;
&lt;li&gt;It would be nice if it wasn't completely impossible to read.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;The Experiment&lt;/h1&gt;
&lt;p&gt;I spent some time this afternoon to attempt an implementation, and
wound up with the following scheme: I'd focus just on dispatching
function (method) calls, and use interface and implementation keys to
look up the concrete procedure in question. ABL does allow procedures
to be dynamically invoked, so by returning a procedure, we can also
punt parameter passing to the caller.&lt;/p&gt;
&lt;p&gt;Here's what it looks like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* Top-level include for the runtime and type definition. */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;interfaces&lt;span class="o"&gt;.&lt;/span&gt;i&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;NEW&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;NEW&amp;quot;&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Declare an interface method (mostly just for compiler support). */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;define&lt;span class="o"&gt;-&lt;/span&gt;interface&lt;span class="o"&gt;.&lt;/span&gt;i&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;igreeter.sayhello&amp;quot;&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* You can now use {&amp;amp;igreeter.sayhello} to refer to this&lt;/span&gt;
&lt;span class="cm"&gt;interface. */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
DEFINE&lt;span class="w"&gt; &lt;/span&gt;VAR&lt;span class="w"&gt; &lt;/span&gt;greeter&lt;span class="w"&gt; &lt;/span&gt;AS&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;INTERFACE&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;NO&lt;span class="o"&gt;-&lt;/span&gt;UNDO&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
greeter&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;igreeter&lt;span class="o"&gt;.&lt;/span&gt;sayhello&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To supply an implementation of a method, you create a normal procedure
and register it with an implementation class:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;{implements.i {&amp;amp;igreeter.sayhello} greeter.english hello.p}
{implements.i {&amp;amp;igreeter.sayhello} greeter.spanish hola.p}

/* The methods can be invoked directly....*/
{invoke.i {&amp;amp;igreeter.sayhello} {&amp;amp;greeter.english}} (&amp;quot;Jimmy&amp;quot;).
{invoke.i {&amp;amp;igreeter.sayhello} {&amp;amp;greeter.spanish}} (&amp;quot;Jimmy&amp;quot;).

/* ...or by passing implementation classes around. */
PROCEDURE SayHi:
    DEFINE INPUT PARAM klass AS {&amp;amp;INTERFACE} NO-UNDO.
    DEFINE INPUT PARAM name AS CHARACTER NO-UNDO.
    {invoke.i {&amp;amp;igreeter.sayhello} klass} (name).
END.

RUN SayHi({&amp;amp;greeter.english}, &amp;quot;Jimmy&amp;quot;).
RUN SayHi({&amp;amp;greeter.spanish}, &amp;quot;Jimmy&amp;quot;).
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Results&lt;/h1&gt;
&lt;p&gt;The interfaces (and implementation classes) in this system can be
stored in variables and passed to procedures, require no memory
management, and will even show up nicely in logs. Since they're
referred to with preprocessor macros, typos in interface or class
names will be caught at compile time (procedure names and parameter
lists are not normally checked). It's debatable whether this counts as
"not impossible to read", but it's at least vaguely decipherable, and
it's pretty easy to wrap.&lt;/p&gt;
&lt;p&gt;The current incarnation is pretty basic, and has a number of
limitations:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It only supports procedures (not functions or methods).&lt;/li&gt;
&lt;li&gt;It only support &lt;em&gt;local&lt;/em&gt; procedures (can't call a procedure in another
persistent procedure).&lt;/li&gt;
&lt;li&gt;Procedure parameters aren't checked against the interface for consistency.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Implementation&lt;/h1&gt;
&lt;p&gt;The implementation of this scheme is rather strange, mostly because of
preprocessor contortions, though it's also rather small at about 60
lines of code.&lt;/p&gt;
&lt;p&gt;The core is a small runtime that is responsible for registering and
looking up concrete procedures for interface implementations:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;CLASS MethodRuntime:
    DEFINE PROTECTED TEMP-TABLE tt_method NO-UNDO
            FIELD klass AS CHARACTER
            FIELD methodName AS CHARACTER
            FIELD procName AS CHARACTER
            FIELD procHdl AS HANDLE
            INDEX method_index IS PRIMARY
                    klass
                    methodName.

    METHOD PUBLIC VOID RegisterMethod(klass AS CHARACTER, methodName AS CHARACTER):
            FIND FIRST tt_method WHERE tt_method.klass = klass
                            AND tt_method.methodName = methodName
                            NO-LOCK NO-ERROR.
            IF AVAILABLE tt_method THEN DO:
                    ASSIGN tt_method.procName = procName
                            tt_method.procHdl = procHdl.
                    RETURN.
            END.

            CREATE tt_method.
            ASSIGN tt_method.klass = klass
                    tt_method.methodName = methodName
                    tt_method.procName = procName
                    tt_method.procHdl = procHdl.
    END.

    METHOD PUBLIC CHARACTER MethodProc(methodName AS CHARACTER,
                   klass AS CHARACTER):
            FIND FIRST tt_method WHERE tt_method.klass = klass
                            AND tt_method.methodName = methodName
                            NO-LOCK NO-ERROR.
            IF NOT AVAILABLE tt_method THEN DO:
                   FIND FIRST tt_method WHERE tt_method.klass = klass
                                   NO-LOCK NO-ERROR.
                   IF NOT AVAILABLE tt_method THEN
                          RETURN ERROR SUBSITUTE(&amp;quot;No such class&amp;#39;&amp;amp;1&amp;#39;&amp;quot;, klass).
                   ELSE
                          RETURN ERROR SUBSTITUTE(&amp;quot;Class &amp;#39;&amp;amp;1&amp;#39; has no method &amp;#39;&amp;amp;2&amp;#39;&amp;quot;,
                                        klass, methodName).
            END.
            RETURN tt_method.procName.
    END.
END.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Internally, classes and interfaces are strings: this allow them to be
created without memory management issues, and means they'll print
nicely in logfiles. They're stored in a temp-table with an index,
since we expect method registration to happen less than method calls,
and we'd like those to be fast if possible.&lt;/p&gt;
&lt;p&gt;The toplevel &lt;code&gt;interfaces.i&lt;/code&gt; include defines a shared instance of the
runtime class, and establishes the opaque &lt;code&gt;{&amp;amp;INTERFACE}&lt;/code&gt; type synonym
for interfaces and implementation classes.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;amp;IF DEFINED(INTERFACES_I_)=0 &amp;amp;THEN
&amp;amp;GLOBAL-DEFINE INTERFACES_I_

&amp;amp;GLOBAL-DEFINE INTERFACE CHARACTER
DEFINE {&amp;amp;NEW} SHARED VAR MethodRuntime AS CLASS MethodRuntime NO-UNDO.

&amp;amp;IF &amp;#39;{&amp;amp;NEW}&amp;#39;&amp;lt;&amp;gt;&amp;#39;&amp;#39; &amp;amp;THEN
MethodRuntime = NEW MethodRuntime().
&amp;amp;ENDIF

&amp;amp;ENDIF
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;define-interface.i&lt;/code&gt; include-macro does very little: it simply
defines a preprocessor name for the string constant that is the
interface name.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;amp;GLOBAL-DEFINE {1} &amp;#39;{1}&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;implements.i&lt;/code&gt; include-macro does the same for the implementation
class, and expands to a call to &lt;code&gt;MethodRuntime:RegisterMethod()&lt;/code&gt;. The
parent-procedure handle parameter of &lt;code&gt;RegisterMethod&lt;/code&gt; is unused for
now.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;amp;GLOBAL-DEFINE {2} &amp;#39;{2}&amp;#39;
MethodRuntime:RegisterMethod({1}, {&amp;amp;{2}}, &amp;quot;{3}&amp;quot;, ?).
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;invoke.i&lt;/code&gt; is a simple expansion to all but the parameter list of a
dynamic procedure call, using the procedure name returned by the
runtime:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;RUN VALUE(MethodRuntime:MethodProc({1}, {2}))
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;It is clearly possible to provide polymorphic functions in ABL, with a
few nice properties, as long as you're willing to accept a slightly
cumbersome syntax and some modest restrictions on the implementations
of methods. Basic compile-time support is doable, and there is no risk
of memory leaks without garbage collector support.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Michael Feathers'
&lt;a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052"&gt;book&lt;/a&gt;
actually includes a tiny little section at the end about working
with C. It consists mainly of the author throwing up his hands and
suggesting you use a real language.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;See the "OOABL" sections toward the end. Bear in mind that most
of the "fixed" issues don't apply to the versions we have in the field.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary></entry><entry><title>Look Ma, No IVs!</title><link href="http://mtstickney.github.io/posts/2015/09/01/look-ma-no-ivs.html" rel="alternate"></link><updated>2015-09-01T00:00:00-04:00</updated><author><name>Matthew Stickney</name></author><id>tag:mtstickney.github.io,2015-09-01:posts/2015/09/01/look-ma-no-ivs.html</id><summary type="html">&lt;p&gt;Encryption algorithms in some modes require three parameters for
encryption and decryption: the encryption key, the data (plaintext or
ciphertext) and an Initialization Vector. Storing IVs is a hassle;
what follows is a cute trick for doing encryption in AES CBC-mode
without explicitly storing or transmitting IVs, and without
sacrificing data security.&lt;/p&gt;
&lt;h2&gt;Who Needs IVs, Anyway?&lt;/h2&gt;
&lt;p&gt;First, a brief note on IVs: Initialization Vectors are actually a
critical piece of strong encryption in CBC mode. Without it, or with a
poorly chosen IV, the encrypted data is subject to known-ciphertext
attacks (i.e. it's not
&lt;a href="https://en.wikipedia.org/wiki/Semantic_security"&gt;semantically secure&lt;/a&gt;). In
order to function properly, the IV used to encrypt and decrypt data
needs to be cryptographically random. If your library makes the mistake
of having one, it can be tempting to use the "don't use an IV" option
just for convenience. This is a Bad Idea(tm); just say no.&lt;/p&gt;
&lt;h2&gt;Quirks of CBC Mode&lt;/h2&gt;
&lt;p&gt;In CBC mode, each block is encrypted and then &lt;code&gt;XOR&lt;/code&gt;ed with the
preceding output block. That is, &lt;code&gt;out[n] = encrypt(key, (input[n] XOR
out[n-1]))&lt;/code&gt;. The first block, which has no preceding output block, is
&lt;code&gt;XOR&lt;/code&gt;ed with the IV instead: &lt;code&gt;out[0] = encrypt(key, (input[0] XOR
iv))&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Decryption works the same way, but in reverse: &lt;code&gt;out[n] = decrypt(key,
input[n]) XOR input[n-1]&lt;/code&gt;, and &lt;code&gt;out[0] = decrypt(key, input[0]) XOR
iv&lt;/code&gt;. Note that the decrypted block &lt;code&gt;n&lt;/code&gt; doesn't require the &lt;em&gt;decrypted&lt;/em&gt;
block &lt;code&gt;n-1&lt;/code&gt;, just the &lt;em&gt;encrypted&lt;/em&gt; block &lt;code&gt;n-1&lt;/code&gt; that you were handed to
decrypt.&lt;/p&gt;
&lt;p&gt;Suppose you have a message with two blocks, &lt;code&gt;p[0]&lt;/code&gt; and &lt;code&gt;p[1]&lt;/code&gt;, which
were encrypted with a key &lt;code&gt;k&lt;/code&gt; and an IV &lt;code&gt;iv1&lt;/code&gt; into a ciphertext (call
the ciphertext blocks &lt;code&gt;c[0]&lt;/code&gt; and &lt;code&gt;c[1]&lt;/code&gt;). Now lets see what happens if
we try to decrypt that with a completely different IV, &lt;code&gt;iv2&lt;/code&gt;: for the
first block, we first decrypt the ciphertext block to get &lt;code&gt;p[0] XOR
iv1&lt;/code&gt; and then &lt;code&gt;XOR&lt;/code&gt; it with out IV, &lt;code&gt;iv2&lt;/code&gt;. Whoops!  Unless &lt;code&gt;iv1&lt;/code&gt; and
&lt;code&gt;iv2&lt;/code&gt; happen to be the same, &lt;code&gt;p[0] XOR iv1 XOR iv2&lt;/code&gt; is going to be
garbage. So much for the first block.&lt;/p&gt;
&lt;p&gt;But wait! What about the second block? First we decrypt the ciphertext
block to get &lt;code&gt;p[1] XOR c[0]&lt;/code&gt;, and then we &lt;code&gt;XOR&lt;/code&gt; with the preceding
ciphertext block &lt;code&gt;c[0]&lt;/code&gt; to get &lt;code&gt;p[1] XOR c[0] XOR c[0]&lt;/code&gt;, which most
certainly &lt;em&gt;does&lt;/em&gt; equal our original plaintext block &lt;code&gt;p[0]&lt;/code&gt;. We've
successfully decrypted the data and the IV hasn't even come into the
picture, and this will also be true for any subsequent ciphertext
blocks for the same reason. In other words, if we encrypt and decrypt
with two different IVs, we only lose the first block of data.&lt;/p&gt;
&lt;h2&gt;Spooky IV Action at a Distance&lt;/h2&gt;
&lt;p&gt;The obvious way to exploit this behavior is to have the encrypting
party and the decrypting party generate independent cryptographically
random IVs, and treat the first block of data as sacrificial
garbage&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;. Since the encrypting side and decrypting side aren't
using the same IV, they don't need to store or transmit it. The
encrypted data will be a block larger (the same as if you were to
concatenate the IV and the ciphertext), and there is one extra encrypt
and decrypt operation.&lt;/p&gt;
&lt;p&gt;This is a rather cute trick for doing encryption without synchronizing
IVs (and without resorting to an all-zero IV and sacrificing data
security), but it's only applicable to CBC-mode, which you probably
shouldn't be using. CBC-mode doesn't do authentication, which is
Bad&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;; you should use an authenticating mode like
&lt;a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode"&gt;GCM&lt;/a&gt; or
&lt;a href="https://en.wikipedia.org/wiki/EAX_mode"&gt;EAX&lt;/a&gt; instead (or at least use
a Message Authentication Code). Better still, make your life easier
and use a library that avoids insecure modes altogether, like the
excellent &lt;a href="https://libsodium.org"&gt;libsodium&lt;/a&gt;. In short: cryptography
is hard, lets go shopping!&lt;/p&gt;
&lt;h2&gt;Addendum: Credit Where Credit is Due&lt;/h2&gt;
&lt;p&gt;I came up with this scheme while I was exploring the AES encryption in
our system at work, which features an option where "no initialization
vector value is used", after a Stack Overflow answer pointed out that
losing the IV only means losing the first block. However, it's not the
first time someone's come up with the idea:
&lt;a href="http://crypto.stackexchange.com/a/7937"&gt;this answer&lt;/a&gt; refers to the
same scheme.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Fun fact: &lt;code&gt;XOR&lt;/code&gt; is entropy-preserving (i.e. the enropy of &lt;code&gt;a XOR
b&lt;/code&gt; is the maximum of &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt;'s entropy) so having a random or
all-zero (or any other) value here doesn't decrease the entropy
contributed by the IV. CBC-mode relies on this property to work, since
the ciphertext might naturally have any value in a block.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;This is surprising to many people, but without a special
provision for message authentication, encryption ciphers have no way
to tell the difference between a legitimately encrypted message and
random garbage (and this is a good thing). It is surprisingly easy to
produce certain kinds of outputs by modifying the ciphertext, and a
non-authenticating mode like CBC will happily decrypt it without any
idea that it's been tampered with.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="cryptography"></category><category term="encryption"></category><category term="AES"></category><category term="programming"></category></entry><entry><title>Infrastructure Notes: Pelican Setup</title><link href="http://mtstickney.github.io/posts/2015/04/26/infrastructure-notes-pelican-setup.html" rel="alternate"></link><updated>2015-04-26T00:00:00-04:00</updated><author><name>Matthew Stickney</name></author><id>tag:mtstickney.github.io,2015-04-26:posts/2015/04/26/infrastructure-notes-pelican-setup.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;I have slipped the surly bonds of Octopress&lt;br /&gt;
 pulled the trigger&lt;br /&gt;
 and converted this sucker to Pelican.&lt;br /&gt;
 -- definitely not John Gillespie Magee, Jr.&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This blog used to be powered by &lt;a href="http://octopress.org"&gt;Octopress&lt;/a&gt;, but
I've just finished converting the whole thing to
&lt;a href="http://blog.getpelican.com"&gt;Pelican&lt;/a&gt;, and wanted to make a few notes
about the switch and the current setup.&lt;/p&gt;
&lt;h2&gt;Updates&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;2015-09-01&lt;/em&gt;: Deploy script was updated to remove the output files
before regenerating the site.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Why Switch?&lt;/h2&gt;
&lt;p&gt;First though, a comment about my reasons for switching: Octopress is a
solid piece of software, with good out-of-the-box settings for the
sort of blogging I want to do (and probably for most blogs in
general). So why the switch? In my case, the two killer issues were
Ruby and the deployment scenario.&lt;/p&gt;
&lt;p&gt;Getting Ruby to run on Windows is an absolute nightmare (mainly a
problem with gems). I generally prefer Linux systems, but some of my
machines are Windows-based and the harder it is to update the site the
less likely I am to actually do it. I'm also not as familiar with
Ruby, so the barrier for hacking on Octopress is higher, although I
doubt I'd have needed to do so.&lt;/p&gt;
&lt;p&gt;Octopress is designed to run on the github-pages platform, and has
Rake tasks to support updating and deploying the site. Unfortunately
it's not completely clear what these are actually doing -- they commit
the contents of a folder to the &lt;code&gt;master&lt;/code&gt; or &lt;code&gt;gh-pages&lt;/code&gt; branch of a
repo, which is an unusual operation in git -- which makes it easy to
make mistakes. I use git every day, and I still managed to commit the
generated site but not my article source. On top of that, you get
octopress by forking the author's repo, which makes it tricky to
update octopress itself.&lt;/p&gt;
&lt;p&gt;Octopress' author has &lt;a href="octopress-3.0"&gt;noted&lt;/a&gt; the issues with the
deployment process, and has plans to fix them in a future version, but
that still leaves me with the Ruby issues. "Figure out Octopress" has
been on my To-Do list for so long that I'm not actually writing (last
post was more than a year ago), which in the end is the whole point,
so after much procrastinating I'm pulling the trigger and switching to
Pelican.&lt;/p&gt;
&lt;h2&gt;The Setup&lt;/h2&gt;
&lt;p&gt;First, create a virtualenv for the site in question:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;mkdir my_site/ &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nb"&gt;cd &lt;/span&gt;my_site/
&lt;span class="nv"&gt;$ &lt;/span&gt;virtualenv .
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;source &lt;/span&gt;Scripts/activate
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Next, install the pelican components and create the project skeleton:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;pip install pelican markdown typogrify
&lt;span class="nv"&gt;$ &lt;/span&gt;pelican-quickstart
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It's not a great idea to add the virtualenv components to the git
repo, but we do want to track the installed components so setup on a
new machine is easy. The best way I've found to do that is to save the
requirements list from pip:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;pip -l freeze &amp;gt; requirements.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You'll want to add Pelican's files, the requirements file, and any
existing content (but not the &lt;code&gt;output/&lt;/code&gt; folder just yet):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git add pelicanconf.py &lt;span class="se"&gt;\&lt;/span&gt;
          publishconf.py &lt;span class="se"&gt;\&lt;/span&gt;
          Makefile &lt;span class="se"&gt;\&lt;/span&gt;
          fabfiile.py &lt;span class="se"&gt;\&lt;/span&gt;
          develop_server.sh &lt;span class="se"&gt;\&lt;/span&gt;
          requirements.txt &lt;span class="se"&gt;\&lt;/span&gt;
          content/
&lt;span class="nv"&gt;$ &lt;/span&gt;git commit -m &lt;span class="s1"&gt;&amp;#39;Add Pelican files.&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I like Octopress' default theme, so I'm using the
&lt;a href="pelican-octopress"&gt;pelican-octopress&lt;/a&gt; theme. There is a small
issue with the github scripts it uses for the sidebar, but I'm hoping
to submit a patch for that shortly. This is also the one and only part
of the site that I haven't figured out how to store in the main repo
yet (a submodule would probably do it). Installation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git clone https://github.com/duilio/pelican-octopress-theme.git ../pelican-octopress
&lt;span class="nv"&gt;$ &lt;/span&gt;pelican-theme -i ../pelican-octopress
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Github Pages&lt;/h2&gt;
&lt;p&gt;Getting Pelican's output into the right branch for Github Pages can be
a little tricky to wrangle (this was the most confusing part of
Octopress for me), but there are several ways to approach the
problem. I chose to stick with Octopress' &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;master&lt;/code&gt; (or
&lt;code&gt;gh-pages&lt;/code&gt;) branch scheme, where the code for generating the site
resides in the &lt;code&gt;source&lt;/code&gt; branch of the same repo as the site. Using an
external repo could also work, but I didn't want the clutter.&lt;/p&gt;
&lt;p&gt;Instead of using an existing script like &lt;code&gt;ghp-import&lt;/code&gt; and trying to
convince it to use &lt;code&gt;master&lt;/code&gt; instead of &lt;code&gt;gh-pages&lt;/code&gt;, I was able to roll
my own deployment script quite easily using &lt;code&gt;git subtree&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The first thing to do is to add the &lt;code&gt;output/&lt;/code&gt; directory as a subtree
from the master branch:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git subtree add --prefix output/ origin master
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then we can use a deployment script to generate the site, commit the
changes, and push the generated content to the master branch:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/sh&lt;/span&gt;

&lt;span class="nv"&gt;OUTPUT_DIR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;output
&lt;span class="c"&gt;# Generate fresh production output&lt;/span&gt;
rm -rf &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$OUTPUT_DIR&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
pelican -s publishconf.py

&lt;span class="c"&gt;# Just to be safe, make sure we don&amp;#39;t commit already-staged changes&lt;/span&gt;
git reset HEAD

&lt;span class="c"&gt;# Add and commit the new output&lt;/span&gt;
git add --all &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$OUTPUT_DIR&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;DATE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;date -u &lt;span class="s2"&gt;&amp;quot;+%Y-%m-%d %H:%M:%S %Z&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
git commit -m &lt;span class="s2"&gt;&amp;quot;Site updated at &lt;/span&gt;&lt;span class="nv"&gt;$DATE&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# Push it to the remote&lt;/span&gt;
git subtree push --prefix &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$OUTPUT_DIR&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; origin master
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Works like a charm, and I (now) know exactly what it's doing. The only
thing missing is &lt;code&gt;git pull&lt;/code&gt;ing the new &lt;code&gt;master&lt;/code&gt;, but you generally
won't even have it checked out locally.&lt;/p&gt;
&lt;h2&gt;New Machine Setup&lt;/h2&gt;
&lt;p&gt;With all that in place, setup on a new machine is pretty
straightforward, assuming Python is already installed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git clone https://github.com/mtstickney/mtstickney.github.com site
&lt;span class="nv"&gt;$ &lt;/span&gt;git clone https://github.com/duilio/pelican-octopress-theme.git pelican-octopress
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;site
&lt;span class="nv"&gt;$ &lt;/span&gt;virtualenv .
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;source &lt;/span&gt;Scripts/activate
&lt;span class="nv"&gt;$ &lt;/span&gt;pip install -r requirements.txt
&lt;span class="nv"&gt;$ &lt;/span&gt;pelican-themes -i ../pelican-octopress
&lt;span class="nv"&gt;$ &lt;/span&gt;&amp;lt;write write write&amp;gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;./deploy.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;This is a shameless ripoff of John Gillespie Magee Jr.'s fabulous
  poem
  &lt;a href="http://www.woodiescciclub.com/high-flight.htm"&gt;High Flight&lt;/a&gt;. You
  should go read it.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="infrastructure note"></category><category term="blog"></category><category term="meta"></category><category term="pelican"></category><category term="github-pages"></category></entry><entry><title>Abusing Search Paths for Fun and Profit</title><link href="http://mtstickney.github.io/posts/2013/02/12/abusing-search-paths-for-fun-and-profit.html" rel="alternate"></link><updated>2013-02-12T00:00:00-05:00</updated><author><name>Matthew Stickney</name></author><id>tag:mtstickney.github.io,2013-02-12:posts/2013/02/12/abusing-search-paths-for-fun-and-profit.html</id><summary type="html">&lt;p&gt;What do you do when you have to use an undocumented function? Reverse
engineer it, naturally. I was recently in the position of having to
automate some functions of an interactive tool provided by my language
environment. The language docs said the procedure I needed could be
extracted from a library distributed with the tool, but neglected to
mention what it's parameters were or what data needed to be passed.&lt;/p&gt;
&lt;p&gt;The extracted procedure was a bytecode-compiled file, so I couldn't
examine the code, but I found a handy &lt;a href="https://gist.github.com/abevoelker/581127"&gt;script&lt;/a&gt; that
would extract the parameter information from the bytecode. That wasn't
enough to use the procedure, but it did give me an idea: if I could
replace the standard procedure with my own version, I could have it
report the input it was getting when it was called.&lt;/p&gt;
&lt;p&gt;I had traced the tool in Process Monitor earlier, and noticed that it
always searched for raw-source procedure files before bytecode files,
and for bytecode files before looking in a procedure library. I
whipped up a quick version of the procedure I wanted to call with the
right parameters, which would just report its input when run, and
plopped it next to the procedure library I'd extracted the bytecode
file from. I fired up the tool, pointed it at a file, and sure enough
it ran my procedure, reported the data, and promptly crashed.&lt;/p&gt;
&lt;p&gt;That gave me enough information to use the real procedure file,
despite the total lack of documentation. The moral of the story here
is that language search paths often be used to hook parts of an
application that would otherwise be hard to reach, whether it's
bytecode files or DLLs (LD_PRELOAD, anyone?).&lt;/p&gt;</summary><category term="worklog"></category><category term="abl"></category></entry></feed>